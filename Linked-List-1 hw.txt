Linked-List-1

Problem1 (https://leetcode.com/problems/reverse-linked-list/)

Time Complexity: O(N)
Space Complexity: O(1)

class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None or head.next == None:
            return head

        prev = None
        curr = head
        fast = head.next
        while fast != None:
            curr.next = prev
            prev = curr
            curr = fast
            fast = fast.next
        curr.next = prev

        return curr


Problem2 (https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

Time Complexity: O(n)
Space Complexity: O(1)

class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        if head == None:
            return head
        
        dummy = ListNode(-1)
        dummy.next = head
        slow = dummy
        fast = dummy
        cnt = 0
        while cnt <= n :
            fast = fast.next
            cnt = cnt + 1
        while fast != None:
            slow = slow.next
            fast = fast.next
        slow.next = slow.next.next
        return dummy.next


Problem3 (https://leetcode.com/problems/linked-list-cycle-ii/)

Time Complexity: O(N)
Space Complexity: O(1)

class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None:
            return None
        
        hascycle = False
        slow = head
        fast = head
        while fast != None and fast.next != None:
            slow = slow.next
            fast = fast.next.next
            
            if slow == fast:
                hascycle = True
                break
            
        if hascycle == False:
            return None
        
        fast = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return slow


